\documentclass[ngerman]{gdb-aufgabenblatt}

\usepackage{enumitem}
\usepackage{dingbat}
\renewcommand{\Aufgabenblatt}{1}
\renewcommand{\Ausgabedatum}{Mi. 18.10.2017}
\renewcommand{\Abgabedatum}{Fr. 03.11.2017}
\renewcommand{\Gruppe}{Meimerstorf,Jochens,Töter}
\renewcommand{\STiNEGruppe}{19}
\usepackage{tabularx}


\begin{document}

\section{Informationssysteme}
\subsection{Charakterisierung}
Ein Informationssystem ist ein informationstechnologisch untersütztes Anwendungssystem, also im Endeffekt ein Computersystem, welches betriebliche Aufgaben ausführt. Charakterisierend für ein Datenbanksystem ist eine leichte Handhabbarkeit der Daten, die Kontrolle der Datenintegrität und die Kontrolle über die operationalen Daten, außerdem im heutigen Status in Zeiten von Amazon und google ist auch die Leistung und Skalierbarkeit der Daten wichtig. Die Skalierbarkeit, da eine Datenbank für eine kleine Webanwendung sowie auch für ein großes DB-System wie Amazons Nutzerverwaltung funktionieren muss. \\
\textbf{Aufgaben:} 
\begin{enumerate}[label=\arabic*)]
\item Organisieren von Arbeitsabläufen \\
\item Paralleler Zugriff von mehreren Stellen \\
\item Hoher Durchsatz und kurze Antwortzeit \\
\end{enumerate}
\subsection{Datenunabhängigkeit}
Die Datenunabhängigkeit bezeichnet die Unabhängigkeit der Daten und den dazugehörigen Anwendungsprogrammen. Realisiert wird dies meist, dadurch das ein DMS, eine Schnittstelle zu den Daten bereitstellt welche die Anwendungsprogramme dann verwenden können. \\ Daraus folgt auch direkt die physische Unabhängigkeit, welche darstellt, das die Anwendungsprogramme nicht verändert werden müssen wenn sich die physische Speicherungsart der Daten auf der Festplatte ändert. Da sich die Schnittstelle nicht ändert. \\
Die logische Unabhängigkeit bezeichnet, die Robustheit der Anwendungsprogramme gegen Änderungen im Datenbankschema. Dies ist auf jeden Fall bei SQL Datenbanken nicht der Fall, da wenn ich mein Schema verändere ich auch meine SQL-Queries verändern muss. \\ 
\subsection{Beispiele}
\begin{enumerate}
\item SAP System in Unternehmen : Arbeitsabläufe leichter machen.  \\
\item Googles Suchmaschine : Das Internet indizieren und danach mit Anfragen von Usern durchsuchen \\	
\item Geldautomat: Geld abheben, Kontoauszug \\
\end{enumerate}
\section{Miniwelt}
\subsection{relevante Objekte}
\begin{itemize}
\item Spieler \\
\begin{itemize}
\item Anmelden Anwendung \\
\item Tippgemeinschaft erstellen \\
\item Wettbewerbe anlegen \\
\item Begegnungen zu Wettbewerb hinzufügen \\
\item Ergebnisse eintragen \\
\item Spieler zu Gemeinschaft hinzufügen/entfernen \\
\item Tipps abgeben \\
\item Sich über Begegnung informieren, Punkte einsehen etc. \\
\end{itemize}
\item Wettbewerb\\
\begin{itemize}
\item Hat einen Gründer \\
\item Gehört zu einer Tippspielgemeinschaft \\
\end{itemize}
\item Tippgemeinschaft \\
\begin{itemize}
\item Hat verwaltenden Gründer \\
\item Hat n-Wettbewerbe \\
\item Hat n-Mitspieler \\
\item Punktestand für Spieler \\
\end{itemize}
\item Begegnung \\
\begin{itemize}
\item Gehört zu 1 Wettbewerb \\
\item Hat 1 Ergebnis \\
\item Hat n-Tipps \\
\end{itemize}
\item Tipp  \\
\begin{itemize}
\item Hat einen diskreten Wert \\
\item Gehört zu einer Begegnung \\
\item Wird von Spieler erstellt \\
\end{itemize}
\end{itemize}
\subsection{Anforderungen}
\begin{itemize}
\item \textbf{Parallelisierter Zugriff:} \\
Zugriff muss parallel von einer großen Menge von Nutzern erfolgen. Ob diese nun sequentiell abgearbeitet werden oder auch parallel ist abhängig von dem DBM.
\item \textbf{Kontrolle der Datenintegrität:} \\
Daten sollten gesichert werden \\
Daten werden durch Regeln beschrieben \\
\item \textbf{Kontrolle über die operationalen Daten:} \\
Daten nicht redundant speichern. \\
Daten aus dem Tippspiel müssen zugänglich sein. \\
Zusammenhänge auswerten.(Wettbewerb zuende, Tipps auswerten) \\
\item \textbf{Leistung und Skalierbarkeit:} \\
Servergröße und Leistung(Durchsatz,Antwortzeit) an Nutzermenge anpassen. \\
\item \textbf{Hoher Grad an Datenunabhängigkeit:} \\
Backups der Daten \\
Atomarität der Transaktionen festsetzen \\
Rechtesystem für Nutzer in der Datenbank festhalten.(Gründer,Spieler,Admin? etc.) \\
\end{itemize}
Glaube damit haben wir alle aus der Vorlesung noch einmal hochgeholt und mit der Miniwelt verglichen. \\
\newpage

\section{Transaktionen}
\subsection{Zeitpunkt A}
\subsubsection{Dateisystem}
\begin{enumerate}
\item Daten im RAM: \\
Daten im RAM gehen verloren, die gesamte Transaktion muss wiederholt werden.
\item Daten auf Platte: \\
Die Daten wurden bereits geschrieben, heißt wir haben nun das Problem das wir unseren Vorgang nicht einfach wiederholen können da von KontoID = 5 bereits das Geld abgebucht wird. Beim Dateisystem wissen wir allerdings nicht wie weit unsere Transaktion war. Dadurch ist es schwer die Transaktion ohne weitere Mechanismen zu wiederholen. \\
\end{enumerate}
\subsubsection{Datenbanksystem}
\begin{enumerate}
\item Daten im RAM: \\
Die Daten im RAM gehen verloren, die gesamte Transaktion muss wiederholt werden. \\
\item Daten auf Platte: \\
Die Daten wurden bereits geschrieben, heißt also das KontoID = 5 hat bereits 1000 Geld weniger. Das DBM muss könnte nun also genauso wie das Dateisystem von Zeitpunkt A an weitermachen, das geht jedoch gegen das Prinzip der Atomarität(Im Späteren erklärt).
\end{enumerate}
\subsection{Zeitpunkt B}
\subsubsection{Dateisystem}
\begin{enumerate}
\item Daten im RAM: \\
Die Daten gehen verloren die gesamte Transaktion muss wiederholt werden. 
\item Daten auf Platte: \\
Die Daten wurden geschrieben. Es werden allerdings die Daten nicht noch einmal ausgegeben. Diesen Fall könnte man also ignorieren, da der essentielle Teil der Operation durchgeführt wurde. Und einfach die Daten beim nächsten Versuch nur noch einmal ausgeben. 
\end{enumerate}
\subsubsection{Datenbanksystem}
\begin{enumerate}
\item Daten im RAM: \\
Die Daten gehen verloren die gesamte Transaktion muss wiederholt werden. 
\item Daten auf Platte: \\
Die Daten wurden geschrieben, und das Geld erfolgreich verbucht. Die Daten sind also konsistent. Die Transaktion wurde jedoch nicht komplett durchgeführt also muss nach dem Atomaritätsprinzip die Transaktion nochmal durchgeführt werden. 
\end{enumerate}
\subsection{DBM Mechanismen}
\begin{itemize}
\item Durch die Atomarität von Transaktionen in einem DBM, muss eine Transaktion immer ganz oder garnicht durchgeführt werden. Wie bei Zeitpunkt B, wo zwar alles schon geschrieben ist und nur die Ausgabe fehlt. \\
\item Dadurch das die Transaktion durch das DBM durchgeführt wird, müssen wir als Nutzer uns nicht darum kümmern (Im Gegensatz zum Dateisystem) das eine Anfrage wiederholt wird, wenn es zu Fehler kommt, sondern wir können uns darauf verlassen, dass unsere Anfrage komplett ausgeführt wird, wenn wir sie ans DBM übergeben haben. \\
\end{itemize}
\newpage
\section{Warm-Up SQL}
\subsection{Create/Insert}
Mit dem Befehl CREATE TABLE wird eine Tabelle mit dem Namen user in der Datenbank gdb$\_$Gruppe erstellt. Diese enthält dem Befehl entsprechend drei verschiedene Einträge, eine ID welche als primärer Key für die Tabelle verwendet wird, außerdem einen 49 Zeichen langen Char der nicht leer sein darf wenn ein Objekt in die Tabelle eingefügt wird, und als letztes noch das passwort, welches 8 Zeichen lang sein kann und auch nicht leer sein darf. \\
Mit dem zweiten Befehl INSERT INTO wird ein Datensatz bestehend aus (ID,Name,Passwort) in die vorher erstelle Tabelle eingefügt.\\
\subsection{SELECT/DROP}
Mit dem Befehl SELECT * FROM table WHERE, werden alle Datensätze der Tabelle table ausgegeben bei denen die Bedingung welche nach WHERE steht, stimmt. Also in unserem Fall genau unseren Datensatz. Hierbei ist zu beachten, dass durch das * wir alle Spalten des Datensatzes mitgeliefert bekommen und nicht nur eine spezielle Spalte \\
Mit dem Befehl DROP können Tabellen komplett aus der Datenbank gelöscht werden, wobei hier darauf zu achten ist das DROP tatsächlich im Gegensatz zu TRUNCATE die Tabelle löscht und nicht nur den Inhalt der Tabelle. \\
\subsection{ANSI-Sparc - Drei Schema Architektur}
Kleine Anmerkung vorweg: Ich werde einfach kurz erklären welche Teile aus der Drei Schema Architektur vergleichbar sind mit der Ansi Sparc Architektur. Und kurz begründen wieso: 

\begin{center}
  \begin{table}[h]
\begin{tabularx}{\textwidth}{|l|l|X|}
    \hline
    Drei Schema & Aufgabe & Begründung \\ \hline
    Anfragen & Connectors & Über die Connectoren werden die Anfragen an das DBM verschickt(Externe Ebene) \\ \hline
    Optimierer & Optimizer & Beide Optimieren die eingehenden SQL-Anfragen (Konzeptuelle Ebene \\ \hline
    Auswertung & Connection Pool/Parser & Die Anfragen werden hingehend ihrer Semantik, Syntax Berechtigung usw. ausgewertet. (Konzeptuelle Ebene) \\ \hline
Plattenzugriff & File-System & Hier wird der wirkliche Plattenzugriff auf das Dateisystem realisiert.(interne Ebene) \\ \hline   
Plattenzugriff & File-System & Hier wird der wirkliche Plattenzugriff auf das Dateisystem realisiert.(internet Ebene) \\ \hline   
\end{tabularx}
\end{table}
Eigentlich sind die beiden Architekturen schwer zu vergleichen schließlich hat der MySQLServer nur zwei Schichten und die Ansi Sparc drei. Jedoch kann man die externe Ebene gut in den Connectoren sehen die durchaus als Schnittstellt zum User gesehen werden können, ohne das dieser viel Ahnung davon haben muss wie die Datenbank intern funktioniert. Interne und Konzeptionelle Ebene sind jedoch vermischter. Genauso wie auch noch die externe Ebene in den Parser,Connection Pool etc. mit einfließt. \\
\end{center}



\end{document}